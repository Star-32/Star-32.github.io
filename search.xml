<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023.6.1 A  题解</title>
    <url>/2023/08/29/2023.6.1_A_solution/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="543061ce76a25a8e6eb0a438059c72a9ae88dcdafab03dac6353b419b664962e">05cd41db3361879aefb4267e575d7f2d3adb0f93fc048c926a2b70c4c4bf36fc91727ff5752686cb33683ff90f695377357762900d262109aba04f849263e6745586789dce2426db554b79fce86728ae9ad2672e16bbda83437abf086d37e6b2d10b588ef3d3ee8843615ded1e129e653fc2788d17f878f0f1042e239c696c2afc03fd22770af940084028a66ffa395806df7584d715dcde7178ed582e03e1df1181d305a2da7a778da40503e5de7335838f8feb34c785556bbc991770786c1482c633daa805c13f7b97ccb77ad695417bddcb31523c663fbe18f14fc548ca61772b2cb5a82690b15688d89c6e988be46c3007472169c625d691ea7f24be3bae059b83a0000a0ccce16907ee5af215c7e6ecf516d70559b6959a717532fc1306b50c51f2e731609034199d984555907c056cecd54cb9029f149d52269d6f1ea62e438cb7c81a7c4ef46e768ef5f6a9a1d392dccc49f4f2a160571bb01037344c62426e1ca587211b020ba883b3c936cacb8a78e10e4ac69c554527b510620de91dd7e0a17abc53cafa2d3d89e6c110dc4b64427268c5c1d308b98190b6f20536fd5e99dce671770aa3f85c4774bf70f9567af8198529b76f59502fb14c49bbe7a61556dbc72dfd6687af5cb2f78a8d9b8dda2d461649b2a4a87a703b1d1baa8d2fbc03ab6775a754e605bd445ae2b4a3fe0750dd4768be819f5394f89e116ab0b4cc75d964924c32c33475aee51775ad8637ad6d6b4fa6dbc18afec0257f953baf388c88b4416c3664b79b6926d3e98bde53e03d832500ac30b04ddbf44c8c01ee236063b97a9ee17bec6e96793dc1b688ffd8d755af5afc31619bdd9fe7c26de18fac499fe52144b3820fc0864a29733535001d543c0ea9532a32d7d7d4dcd3eed8ddfa32d6d47be98204c4c1ae996f9869a57882190d93b0fd08abcf7331e01b1fc639872ce1bc07ee72f4b90b7256614fb1a196672cbb9cfb7ee99c7e831d23a007b9a82a2ec7ba02fd05f020ef2bec6a52f26698c5f350a6cd4a2d1e001e5acc2b9da2161de1d9d09f465bb19c77c3512108a24758ba63030030e11c97bf3df0b30815f4fb3199eb59a1bc9699f9bdacfa7984f570a855d39ff1a318bfa8aa27b67402d11d7c67500f20ea713bc728b162722aa52a5b2947d5cd824c89891b988d8f77c9ac14ee67cc5dab41001f44434285a0cce742023672717973fbd5d3879f9e5591c034d4bb3f970350a79cba5e00e5412b6d7ddbc1cd4b1ed00e3cd62e533f20eab1fd4f52224125523f13</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC056A  题解</title>
    <url>/2023/08/29/AGC056A-solution/</url>
    <content><![CDATA[<p>考试的时候做到这道题，很多小朋友好像都是坐板凳搜出来的捏~</p>
<p>老用户花了好久终于手玩出了一个构造方案，感觉还算比较简洁，分享给大家。</p>
<h4 id="对于-n-equiv-0-pmod-3-的情况"><a href="#对于-n-equiv-0-pmod-3-的情况" class="headerlink" title="对于 $n\equiv 0 \pmod{3}$ 的情况"></a>对于 $n\equiv 0 \pmod{3}$ 的情况</h4><p>不难发现，我们有一种比较简单的构造方案，即每行循环移位 $3$ 格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###......</span><br><span class="line">...###...</span><br><span class="line">......###</span><br><span class="line">###......</span><br><span class="line">...###...</span><br><span class="line">......###</span><br><span class="line">###......</span><br><span class="line">...###...</span><br><span class="line">......###</span><br></pre></td></tr></table></figure>

<p>这样就比较简单地解决了这种情况，相信大家都能想到。</p>
<h4 id="对于-n-equiv-1-pmod-3-的情况"><a href="#对于-n-equiv-1-pmod-3-的情况" class="headerlink" title="对于 $n\equiv 1 \pmod{3}$ 的情况"></a>对于 $n\equiv 1 \pmod{3}$ 的情况</h4><p>我们试图基于上面的情况做一些调整。首先还是每行移位 $3$ 格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###....</span><br><span class="line">...###.</span><br><span class="line">##....#</span><br><span class="line">..###..</span><br><span class="line">#....##</span><br><span class="line">.###...</span><br><span class="line">....###</span><br></pre></td></tr></table></figure>

<p>这时我们发现连通块个数不对呀？怎么办呢？</p>
<p>注意到，我们可以把这个图看做 $3$ 组：每一组刚好占满一整行。则上图中第一组的最后一行和第二组的第一行重叠了，多产生了一个连通块。这时我们想通过调整消去第一组的一个连通块，即上图中第三行的最后一个 <code>#</code>。</p>
<p>我们需要用到一个调整的操作：如果 $(x_1,y_1),(x_2,y_2)$ 都染了色，我们可以调整为给 $(x_1,y_2),(x_2,y_1)$ 染色。这个操作的对行列个数显然是没有影响的。我们可以拿他来改变连通块个数。</p>
<p>回到上面，我们考虑把第三行的最后一个 <code>#</code> 和第四行的最后一个 <code>#</code> 拿来调整，会发现连通块的个数刚好减少了！给下面最对称操作后得到的图是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###....</span><br><span class="line">...###.</span><br><span class="line">##..#..</span><br><span class="line">#..#..#</span><br><span class="line">..#..##</span><br><span class="line">.###...</span><br><span class="line">....###</span><br></pre></td></tr></table></figure>

<p><strong>归纳一下</strong>：在循环移位后，我们给 $(n&#x2F;3+1,n),(n&#x2F;3\times2,n-2)$ 这两个位置和他们的对称位置分别做调整，就可以构造出解。</p>
<h4 id="对于-n-equiv-2-pmod-3-的情况"><a href="#对于-n-equiv-2-pmod-3-的情况" class="headerlink" title="对于 $n\equiv 2 \pmod{3}$ 的情况"></a>对于 $n\equiv 2 \pmod{3}$ 的情况</h4><p>有了上面的经验，这一步就简单多了。大家可以自己手玩一下，这里给出<strong>归纳结论</strong>：在循环移位后，我们给 $(n&#x2F;3+1,1),(n&#x2F;3\times 2+1,n-3)$ 这两个位置和他们的对称位置分别做调整，就可以构造出解。</p>
<p>这样，我们就解决了这道题！是不是很简洁呢？当然还有其他的构造&#x2F;坐板凳方法，大家可以私信 @<a href="https://www.luogu.com.cn/user/291248">赵悦岑</a> 了解。</p>
<p>最后放一个 $n&#x3D;7,8,10,11$ 的构造图希望能帮助到大家：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9jhvrgsc.png"></p>
]]></content>
      <tags>
        <tag>题解</tag>
        <tag>AGC</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC152B  题解</title>
    <url>/2023/08/29/ARC152B-solution/</url>
    <content><![CDATA[<h3 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h3><p>在一条细长的路上有若干个休息区，有两个人在走路。每个人都需要从某一休息区出发，到达路的两个端点并返回初始休息区。由于路很狭窄，两人只能在休息区相遇，也就是说某人可能需要在某一休息区等另外一个人。请你做出合适的安排使得从两人出发到两人都回到出发点的总时间最少。</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>约定：令 $x,y$ 分别表示两人的出发点，钦定 $x&lt;y$；令 $t,w$ 分别表示两次的相遇点。</p>
<p>阅读题目后，不难发现，除非两人从同一点出发，否则他们一定会相遇两次。</p>
<p>由于两人必须在等候区相遇，我们容易发现两人在第一次相遇后会同时同地反向出发。</p>
<p>由此，我们可以容易地找到他们第二次相遇的等候区。设第一次在 $t$ 相遇，则第二次在离 $l-t$ 最近两个等候区之一相遇。</p>
<p>我们令 $S$ 表示两次相遇之间经过的时间，则有 $S&#x3D;\max(t+w,2l-t-w)$，这个式子的两部分分别表示到达左边的端点并折返与到达右边的端点并折返。</p>
<p>如果两人从同一端点出发，则答案就为 $2S$，原因显然。</p>
<p>否则答案为 $\text{第一次相遇的时间}+\text{第二次相遇后回出发点的时间}+S$。</p>
<p>下面我们来研究这个第一次相遇的时间。</p>
<ul>
<li><p>同向出发：<br>$$<br>ans&#x3D;\max(t+x,y-t)+\max(w-x,2l-w-y)+S<br>$$</p>
</li>
<li><p>反向出发：<br>$$<br>ans&#x3D;max(x+t,2l-t-y)+max(w-x,y-w)+S<br>$$</p>
</li>
</ul>
<p>我们发现，无论是哪一种情况，这个 $ans$ 的左边部分都一定不小于 $S$，因为 $S$ 中的两种情况在 $ans$ 中都有出现。因此，我们证明了两人从同一端点出发一定能获得最优解。</p>
<p>以上过程明晰了过后，代码也就很简单了（鸣谢 @<a href="https://github.com/Sukwants">Sukwants</a> @ <a href="https://www.luogu.com.cn/blog/songgch/">Song_gch</a> 两位大佬的思路和代码）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> L, a[MAXN + <span class="number">5</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> Ans = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>, &amp;N, &amp;L);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, a + i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + N + <span class="number">1</span>, L - a[i]) - a;</span><br><span class="line">        Ans = <span class="built_in">min</span>(Ans, <span class="built_in">min</span>(x &lt;= N ? (a[i] + a[x]) : <span class="number">0x3f3f3f3f3f3f3f3f</span>, x &gt; <span class="number">1</span> ? ((L &lt;&lt; <span class="number">1</span>) - a[i] - a[x - <span class="number">1</span>]) : <span class="number">0x3f3f3f3f3f3f3f3f</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, Ans &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>题解</tag>
        <tag>ARC</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组高阶知识</title>
    <url>/2023/08/29/BIT_plus/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0c792a4166a464595dc1aaf6b98dc8f7de784cc5cc849a07a9c1b9371b870f61">05cd41db3361879aefb4267e575d7f2d310e756734892402d83d3e7facb1a7988e5279bb0cec90e12c6e924cee66b98117ba87437b67a1b39737161b6203be701714798c26d36fcf8df9d7e214c0911e39628e56e56be6177be8b72bf1d056bc9ce57d51a2d556d6eba4c24402c1427a08aac84025313c6b554ad7bb560c88bb774a2743bf38ab99c7a6d0918169253d7075834adc0dc1b5d5de16f95d6c745518486ad20887948871702bbb84f223bb0ff375c15e62431a430755564a56e49cfc2213db50a73de103896ea370868049ae015e6c4678fe898e63c728405d35573e4643d85ac31d7e67180f2d2e744303724ac3a425b6f178495eee43ebe0be6c8a03fc530bbcbff0add09997d2813eb0454e1ca6bf86854a63ba998181662c8e084c561a72e6ffba00f1ffc0da5802fd33c194160adb4f738ef9abc73121f2bac1edb6f0de4a5fa8a39b41ea7c59219ba1d08d8512e47f4e1d863414f82f698dc7936fe754486ecef679035caa973608bc6b9b8f16056ee556f5376b19b8f154</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1322E  题解</title>
    <url>/2023/08/29/CF1322E-solution/</url>
    <content><![CDATA[<p>转换为 $01$ 序列的操作其他题解都已经讲的很清楚了，我这里主要提供一种只用线段树来维护答案的方法。</p>
<p>首先是得到操作数。初始序列上是全 $0$ 的，我们从小到大枚举每个数，并把他们修改成 $1$。由于答案是 $01$ 交错段的长度的一半，我们线段树上的每个结点分别维护左部是 $0&#x2F;1$，右部是 $0&#x2F;1$，左部交错段的长度，右部交错段的长度，区间内交错段的最大长度。向上转移比较容易。</p>
<p>然后是得到最后的操作序列。如果一个位置在当前位置由 $0$ 变成 $1$ 之后，在<strong>操作完后</strong>的序列中由 $0$ 变成了 $1$，那么可以认为这个位置在操作完后变成了当前改变的这个位置的值。而一个位置能影响到的位置，只有他改变完后所在的最长 $01$ 段和<strong>他左右两个 $1$ 所在的最长 $01$ 段</strong>。注意第二部分是很容易忽略掉的。具体影响的位置要根据 $01$ 段最外面的两边具体是 $0$ 还是 $1$ 进行分类讨论。找到他影响的区间后做一个区间 $\min$ 即可（因为可能之前的已经修改过去了），这部分可以用一个标记永久化的线段树实现。</p>
<p><a href="https://codeforces.com/contest/1322/submission/194856264">提交记录</a></p>
]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1534H  题解</title>
    <url>/2023/08/29/CF1534H-solution/</url>
    <content><![CDATA[<p>第一次 DP 的部分和后面交互的部分现有的两篇题解都讲的比较清楚了，这里注意补充解释一下换根和计算答案的部分，（让像我这样的菜鸡容易理解一点）。</p>
<p>我们先列出第一次 DP 的式子：<br>$$<br>f_u&#x3D;\max\limits_{i&#x3D;0}^{size-1} f_v+i<br>$$<br>那么我们考虑当前节点是 $u$ ，新的根是 $v$，那么此时我们要抛弃掉 $v$ 对 $u$ 的贡献并且加入 $fa_u$ 对 $u$ 的贡献。考虑直接将与 $u$ 相连的所有点按 $f$ 值进行排序，那么每次的 $v$ 将整个数组分割成一个前缀和一个后缀，式子其实就是上面那个式子，但是后缀部分的 $i$ 要减去当前这个 $v$ 所多算的 $1$。因此不需要什么平衡树，只用预处理前缀最大值、后缀最大值，中间再合并一下就好了。</p>
<p>计算答案的部分则是简单的分类讨论。我们在计算前仍然需要对所有儿子按 $f$ 值排序。对于当前根是 $u$ ，有 $3$ 种情况：</p>
<ol>
<li>询问的两个点分别在当前节点的两个不同子树内，则贡献为 $\max f_{v0}+f_{vi}+i-1$；</li>
<li>询问的两个点中有一个是当前根，则贡献为 $f_{v0}+deg_u-1$；</li>
<li>询问的两个点都是当前的根，则贡献为 $deg_u$。</li>
</ol>
<p>放一下这个关键的 DFS 部分的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool cmp(int x,int y)&#123;</span><br><span class="line">	return f[x]&gt;f[y];</span><br><span class="line">&#125;</span><br><span class="line">void dfs2(int u,int fa)&#123;</span><br><span class="line">	sort(e[u].begin(),e[u].end(),cmp);</span><br><span class="line">	for(int i=1;i&lt;e[u].size();i++)maxm=max(maxm,f[e[u][0]]+f[e[u][i]]+i-1);</span><br><span class="line">	maxm=max(maxm,max(f[e[u][0]]+(int)e[u].size()-1,(int)e[u].size()));</span><br><span class="line">	pre[0]=suf[e[u].size()+1]=0;</span><br><span class="line">	for(int i=0;i&lt;e[u].size();i++)pre[i+1]=max(pre[i],f[e[u][i]]+i);</span><br><span class="line">	for(int i=e[u].size()-1;i&gt;=0;i--)suf[i+1]=max(suf[i+2],f[e[u][i]]+i);</span><br><span class="line">	for(int i=0;i&lt;e[u].size();i++)&#123;</span><br><span class="line">		res[e[u][i]]=max(pre[i],suf[i+2]-1);</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=0;i&lt;e[u].size();i++)&#123;</span><br><span class="line">		if(e[u][i]==fa)continue;</span><br><span class="line">		f[u]=max((int)e[u].size()-1,res[e[u][i]]);</span><br><span class="line">		dfs2(e[u][i],u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1764H  题解</title>
    <url>/2023/08/29/CF1764H-solution/</url>
    <content><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定长为 $n$ 的序列，初始 $a_i&#x3D;i$。有 $m$ 个操作，操作为给出 $l_i,r_i$ 并将 $[a_{l_i},a_{r_i}]$ 赋值为 $a_{l_i}$。要求对每个 $[i,i+k-1]$，回答保留该区间内的操作后序列中不同元素的数量。</p>
<h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>不难发现，对答案产生贡献的有两种情况：</p>
<ul>
<li><p>没有被执行操作的元素</p>
</li>
<li><p>某次操作左端点的元素</p>
</li>
</ul>
<p>我们尝试分别统计这两种情况。</p>
<p>只考虑维护序列，我们容易想到一种基于均摊的，用 set 暴力维护的做法：在 set 中存下每一个区间，遇到修改操作就找到左右端点所在的 set 区间并将其分裂，暴力删去左右端点之间的区间，插入新区间。</p>
<p>我们想在上述过程中同时预处理我们需要的东西。</p>
<h3 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h3><p>对于第一种情况：我们对 set 中的每个区间同时记录下一个 $time$，表示这个区间最初是第 $time$ 次修改操作插入进去的。假设当前是第 $i$ 次修改操作，将从 set 中删去 $[l,r]$ 这个区间，那么我们可以知道在 $[time+1,i-1]$ 这个时间段以内 $[l,r]$ 是没有被修改过的，可以作为第一种贡献。贡献的范围是所有 $ql&gt;time\and qr&lt;i$ 的询问操作。这是一个经典的二维数点问题，可以用扫描线+树状数组解决。</p>
<p>对于第二种情况：我们需要对每个操作维护 $3$ 个信息，分别是：$pre_i$，该操作之前最后一个覆盖到 $l_i$ 的操作；$go_i$，该操作的原始区间 $[l_i,r_i]$ 被完全覆盖掉的时刻；$ed_i$，该操作彻底不能产生贡献的时刻。如果维护好了这些信息，我们知道这个操作能对 $pre_i&lt;ql\and qr&lt;ed_i\and ql\le i\le qr$ 的询问产生贡献，这同样是一个二维数点问题。</p>
<p>具体的，$pre_i$ 只需要在 set 中插入该操作之前查询即可；$go_i$ 为所有 $time&#x3D;i$ 的区间中被删去时刻的最大值；$ed_i&#x3D;\max (go_i,ed_j[pre_j&#x3D;&#x3D;i])$。</p>
<p>这样这道题就完全解决了。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>感觉只有必要放一下预处理，都来做这题了不至于不会二维数点吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bignod</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,tim;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(bignod b)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> l&lt;b.l;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gonxian</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,v;</span><br><span class="line">&#125;gx[<span class="number">2000015</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	set&lt;bignod&gt; st;</span><br><span class="line">	set&lt;bignod&gt; ::iterator it,ti,it2;</span><br><span class="line">	st.<span class="built_in">insert</span>(bignod&#123;<span class="number">1</span>,n,<span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> l=xg[i].l,r=xg[i].r;</span><br><span class="line">		it=st.<span class="built_in">upper_bound</span>(bignod&#123;l,<span class="number">0</span>,<span class="number">0</span>&#125;),ti=--st.<span class="built_in">upper_bound</span>(bignod&#123;r,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">		it2=it,it2--;</span><br><span class="line">		bignod u=*it2,v=u;</span><br><span class="line">		pre[i]=u.tim;</span><br><span class="line">		<span class="keyword">if</span>(u.r&gt;=xg[i].r)&#123;</span><br><span class="line">			go[u.tim]=<span class="built_in">max</span>(go[u.tim],i);</span><br><span class="line">			st.<span class="built_in">erase</span>(it2);</span><br><span class="line">			<span class="keyword">if</span>(u.l&lt;l)st.<span class="built_in">insert</span>(bignod&#123;u.l,l<span class="number">-1</span>,u.tim&#125;);</span><br><span class="line">			<span class="keyword">if</span>(u.r&gt;r)st.<span class="built_in">insert</span>(bignod&#123;r+<span class="number">1</span>,u.r,u.tim&#125;);</span><br><span class="line">			st.<span class="built_in">insert</span>(bignod&#123;l,r,i&#125;);</span><br><span class="line">			<span class="keyword">if</span>(u.tim+<span class="number">1</span>&lt;=i<span class="number">-1</span>)gx[++cqt]=gonxian&#123;u.tim+<span class="number">1</span>,i<span class="number">-1</span>,r-l+<span class="number">1</span>&#125;;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		st.<span class="built_in">erase</span>(it2);</span><br><span class="line">		<span class="keyword">for</span>(;it!=ti;)&#123;</span><br><span class="line">			go[(*it).tim]=<span class="built_in">max</span>(go[(*it).tim],i);</span><br><span class="line">			<span class="keyword">if</span>((*it).tim+<span class="number">1</span>&lt;=i<span class="number">-1</span>)gx[++cqt]=gonxian&#123;(*it).tim+<span class="number">1</span>,i<span class="number">-1</span>,(*it).r-(*it).l+<span class="number">1</span>&#125;;</span><br><span class="line">			it2=it++;</span><br><span class="line">			st.<span class="built_in">erase</span>(it2);</span><br><span class="line">		&#125;</span><br><span class="line">		u=*ti,st.<span class="built_in">erase</span>(ti);</span><br><span class="line">		go[v.tim]=<span class="built_in">max</span>(go[v.tim],i),go[u.tim]=<span class="built_in">max</span>(go[u.tim],i);</span><br><span class="line">		<span class="keyword">if</span>(v.tim+<span class="number">1</span>&lt;=i<span class="number">-1</span>)gx[++cqt]=gonxian&#123;v.tim+<span class="number">1</span>,i<span class="number">-1</span>,v.r-l+<span class="number">1</span>&#125;;</span><br><span class="line">		<span class="keyword">if</span>(u.tim+<span class="number">1</span>&lt;=i<span class="number">-1</span>)gx[++cqt]=gonxian&#123;u.tim+<span class="number">1</span>,i<span class="number">-1</span>,r-u.l+<span class="number">1</span>&#125;;</span><br><span class="line">		<span class="keyword">if</span>(v.l&lt;l)st.<span class="built_in">insert</span>(bignod&#123;v.l,l<span class="number">-1</span>,v.tim&#125;);</span><br><span class="line">		<span class="keyword">if</span>(u.r&gt;r)st.<span class="built_in">insert</span>(bignod&#123;r+<span class="number">1</span>,u.r,u.tim&#125;);</span><br><span class="line">		st.<span class="built_in">insert</span>(bignod&#123;l,r,i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(it=st.<span class="built_in">begin</span>();it!=st.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">		bignod u=*it;</span><br><span class="line">		<span class="keyword">if</span>(u.tim+<span class="number">1</span>&lt;=m)gx[++cqt]=gonxian&#123;u.tim+<span class="number">1</span>,m,u.r-u.l+<span class="number">1</span>&#125;;</span><br><span class="line">		go[u.tim]=<span class="built_in">max</span>(go[u.tim],m+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=m;i;i--)&#123;</span><br><span class="line">		die[i]=<span class="built_in">max</span>(die[i],go[i]);</span><br><span class="line">		<span class="keyword">if</span>(pre[i])die[pre[i]]=<span class="built_in">max</span>(die[pre[i]],die[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1799E  题解</title>
    <url>/2023/08/29/CF1799E-solution/</url>
    <content><![CDATA[<p>题外话：本来没打这场，但同寝室的巨佬 @<a href="https://www.luogu.com.cn/user/291248">赵悦岑</a> 在打，所以我说帮他口胡一下 E，结果我口胡出来的时候他还没过 B，而且一直到最后都没过！咳咳……</p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个 $n\times m$ 的矩阵，矩阵中有 <code>.</code> 和 <code>#</code>，且 <code>#</code> 构成两个四连通块。请用尽量少的操作，将一些 <code>.</code> 改成 <code>#</code> 使得所有 <code>#</code> 构成一个四连通块，且任意两个 <code>#</code> 的最短路（只经过 <code>#</code> ）为他们的曼哈顿距离。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>由题目要求，我们可以发现一些简单的性质：如果一个格子上下或左右都有 <code>#</code>，则他必定会被染成 <code>#</code>，否则无法满足条件。补充完这些后，如果此时只剩一个连通块，那么就做完了。否则继续考虑这个性质：对于上下左右四个边界，一定只会出现单峰的情况，而且剩下的两个连通块一定是左上-右下或右上-左下的，而且不会有某一行或某一列出现两个 <code>#</code> 属于不同连通块。现在我们只考虑左上-右下型的。一个显然的想法是先分别把左上的右下角补齐，把右下的左上角补齐，再用一条简单的路径把两个连通块连起来。举个例子，如果图是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###....</span><br><span class="line">##.....</span><br><span class="line">##.....</span><br><span class="line">#......</span><br><span class="line">......#</span><br><span class="line">.....##</span><br><span class="line">....###</span><br></pre></td></tr></table></figure>

<p>那么我们补充完后可以是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###....</span><br><span class="line">###....</span><br><span class="line">###....</span><br><span class="line">#####..</span><br><span class="line">....###</span><br><span class="line">....###</span><br><span class="line">....###</span><br></pre></td></tr></table></figure>

<p>不难证明，这样补充填充的 <code>#</code> 一定是最少的。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>有点长，放在<a href="https://codeforces.com/contest/1799/submission/195512267">这里</a>。</p>
]]></content>
      <tags>
        <tag>题解</tag>
        <tag>构造</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1814F  题解</title>
    <url>/2023/08/29/CF1814F-solution/</url>
    <content><![CDATA[<h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>看到这种“只在一段时间出现”的问题，很容易想到线段树分治。而维护连通性显然可以用并查集，为了在线段树上实现撤销操作要用按秩合并不带路径压缩的并查集。但是怎么确定是否和 $1$ 连通呢？我们在叶子节点处理这一信息。考虑在叶子节点处我们给 $1$ 在并查集上的根一个标记，在并查集撤销的时候下传标记，这样就能找到彼时所有满足题意的点了。但还有一点细节：并查集在合并的时候可能某一边已经有标记了，这时候需要减去已有的标记避免后面加上的时候造成混淆。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lid (id&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rid (id&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((tr[id].l+tr[id].r)&gt;&gt;1) </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,top=<span class="number">2e5</span>,L[<span class="number">200005</span>],R[<span class="number">200005</span>],fa[<span class="number">200005</span>],dep[<span class="number">200005</span>],tp,teg[<span class="number">200005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r;</span><br><span class="line">	vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; e;</span><br><span class="line">&#125;tr[<span class="number">800005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	tr[id].l=l,tr[id].r=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">build</span>(lid,l,mid),<span class="built_in">build</span>(rid,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[id].l==l&amp;&amp;tr[id].r==r)&#123;</span><br><span class="line">		tr[id].e.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(u,v));</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid)<span class="built_in">modify</span>(lid,l,r,u,v);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid)<span class="built_in">modify</span>(rid,l,r,u,v);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">modify</span>(lid,l,mid,u,v),<span class="built_in">modify</span>(rid,mid+<span class="number">1</span>,r,u,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> u,v,su,sv;</span><br><span class="line">&#125;stk[<span class="number">400005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">find</span>(u)==<span class="built_in">find</span>(v))<span class="keyword">return</span>;</span><br><span class="line">	u=<span class="built_in">find</span>(u),v=<span class="built_in">find</span>(v);</span><br><span class="line">	<span class="keyword">if</span>(dep[u]&gt;dep[v])<span class="built_in">swap</span>(u,v);</span><br><span class="line">	stk[++tp]=node&#123;u,v,dep[u],dep[v]&#125;;</span><br><span class="line">	teg[u]-=teg[v],fa[u]=v,dep[v]+=dep[u]==dep[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">redo</span><span class="params">(node k)</span></span>&#123;</span><br><span class="line">	fa[k.u]=k.u,dep[k.v]=k.sv;teg[k.u]+=teg[k.v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> pre=tp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tr[id].e.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="built_in">merge</span>(tr[id].e[i].first,tr[id].e[i].second);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tr[id].l==tr[id].r)teg[<span class="built_in">find</span>(<span class="number">1</span>)]++;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">dfs</span>(lid),<span class="built_in">dfs</span>(rid);</span><br><span class="line">	<span class="keyword">while</span>(tp!=pre)<span class="built_in">redo</span>(stk[tp--]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,top);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;L[i],&amp;R[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> u,v;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="type">int</span> ll=<span class="built_in">max</span>(L[u],L[v]),rr=<span class="built_in">min</span>(R[u],R[v]);</span><br><span class="line">		<span class="keyword">if</span>(ll&lt;=rr)<span class="built_in">modify</span>(<span class="number">1</span>,ll,rr,u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(teg[i])cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
        <tag>线段树分治</tag>
      </tags>
  </entry>
  <entry>
    <title>CF457F  题解</title>
    <url>/2023/08/29/CF457F-solution/</url>
    <content><![CDATA[<h3 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h3><p>由于某个节点的操作取决于子树内的操作次数，我们定义“奇子树”为一个操作完整个子树的次数为奇数的子树，“偶子树“类似。</p>
<p>首先有一个很经典的 trick：采用二分，凡是大于等于判定值的赋为 $1$，否则为 $0$，则问题变成了值只有 $0,1$ 的问题。</p>
<p>如果一棵树是“奇子树”，则先手能进行最后一步操作，此时两个子树中只要有一个 $1$ 先手即可获胜。如果一棵树是“偶子树”的话，后手进行最后一步操作，仅当两个子树均为 $1$ 时先手才能获胜。</p>
<p>最简单的情况是一个节点的两个子树均为“偶子树”。此时如果后手在先手必胜的子树内操作，先手有必胜策略，否则先手随便选即可保证自己的胜利。</p>
<p>但是当一个节点的两个子树均为“奇子树“时，我们发现这个策略不管用了。因为先手无法通过跟着后手选来消耗步数，维持自己的必胜态。此时仅当先手”停一步“后仍能胜利才能获得最终的胜利。</p>
<p>因此采用 DP：$f_{u,(0&#x2F;1),(0&#x2F;1&#x2F;2)}$ 表示在 $u$ 子树内，当前是先&#x2F;后手，两个儿子的状态是两个偶数&#x2F;两个奇数&#x2F;一奇一偶的答案。</p>
<h3 id="分类讨论转移"><a href="#分类讨论转移" class="headerlink" title="分类讨论转移"></a>分类讨论转移</h3><p>接下来到了喜闻乐见的大分讨环节。首先把两个儿子都是叶子的情况特判掉。由于当前为后手的情况完全等同于当前为先手情况的相反操作，我们只考虑当前为先手的情况。</p>
<ul>
<li><p>两个子树均为“偶子树”：先手赢得任意子树即可；</p>
</li>
<li><p>两个子树均为“奇子树”：先手在其中一个子树停一手获胜，并在另一子树获胜；</p>
</li>
<li><p>一个子树为“奇子树”，另一个为“偶子树”：先手赢得奇子树，后手无法赢得偶子树或先手在偶子树“停一手”获胜，后手无法赢得奇子树。</p>
</li>
</ul>
<p>这样这道题就做完了。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>看上去也不是很困难，对吗？放一下 DP 转移的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(sz[rid]&amp;<span class="number">1</span>)<span class="built_in">swap</span>(lid,rid);</span><br><span class="line">   <span class="keyword">if</span>(!(sz[u]&amp;<span class="number">1</span>))&#123;</span><br><span class="line">       f[u][<span class="number">0</span>][<span class="number">0</span>]=(f[lid][<span class="number">0</span>][<span class="number">0</span>]&amp;&amp;f[rid][<span class="number">1</span>][<span class="number">0</span>])||(f[lid][<span class="number">1</span>][<span class="number">1</span>]&amp;&amp;f[rid][<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">       f[u][<span class="number">1</span>][<span class="number">0</span>]=(f[lid][<span class="number">1</span>][<span class="number">0</span>]||f[rid][<span class="number">0</span>][<span class="number">0</span>])&amp;&amp;(f[lid][<span class="number">0</span>][<span class="number">1</span>]||f[rid][<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">           f[u][<span class="number">0</span>][i]=f[lid][<span class="number">0</span>][(!sz[rid]&amp;&amp;i==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>]||f[rid][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">           f[u][<span class="number">1</span>][i]=f[lid][<span class="number">1</span>][(!sz[rid]&amp;&amp;i==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>]&amp;&amp;f[rid][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       f[u][<span class="number">0</span>][<span class="number">0</span>]=f[lid][<span class="number">0</span>][sz[lid]&amp;<span class="number">1</span>]||f[rid][<span class="number">0</span>][sz[rid]&amp;<span class="number">1</span>];</span><br><span class="line">       f[u][<span class="number">1</span>][<span class="number">0</span>]=f[lid][<span class="number">1</span>][sz[lid]&amp;<span class="number">1</span>]&amp;&amp;f[rid][<span class="number">1</span>][sz[rid]&amp;<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">           f[u][<span class="number">0</span>][i]=f[u][<span class="number">1</span>][<span class="number">0</span>],f[u][<span class="number">1</span>][i]=f[u][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">if</span>(sz[lid]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">               f[u][<span class="number">0</span>][i]|=(f[lid][<span class="number">0</span>][<span class="number">0</span>]&amp;&amp;f[rid][<span class="number">1</span>][(sz[lid]==<span class="number">1</span>&amp;&amp;i==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>])||(f[lid][<span class="number">1</span>][(sz[rid]==<span class="number">1</span>&amp;&amp;i==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>]&amp;&amp;f[rid][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">               f[u][<span class="number">1</span>][i]&amp;=(f[lid][<span class="number">1</span>][<span class="number">0</span>]||f[rid][<span class="number">0</span>][(sz[lid]==<span class="number">1</span>&amp;&amp;i==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>])&amp;&amp;(f[lid][<span class="number">0</span>][(sz[rid]==<span class="number">1</span>&amp;&amp;i==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>]||f[rid][<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(sz[lid])&#123;</span><br><span class="line">                   f[u][<span class="number">0</span>][i]|=f[lid][<span class="number">0</span>][(!sz[rid]&amp;&amp;i==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>]&amp;&amp;f[rid][<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                   f[u][<span class="number">1</span>][i]&amp;=f[lid][<span class="number">1</span>][(!sz[rid]&amp;&amp;i==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>]||f[rid][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(sz[rid])&#123;</span><br><span class="line">                   f[u][<span class="number">0</span>][i]|=f[lid][<span class="number">1</span>][<span class="number">0</span>]&amp;&amp;f[rid][<span class="number">0</span>][(!sz[lid]&amp;&amp;i==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>];</span><br><span class="line">                   f[u][<span class="number">1</span>][i]&amp;=f[lid][<span class="number">0</span>][<span class="number">0</span>]||f[rid][<span class="number">1</span>][(!sz[lid]&amp;&amp;i==<span class="number">1</span>)?<span class="number">2</span>:<span class="number">1</span>];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>对了，实际实现的时候，可以把 $0,1$ 序列的操作直接变成取最小&#x2F;最大值，从而省去一次二分。</p>
]]></content>
      <tags>
        <tag>题解</tag>
        <tag>CF</tag>
        <tag>DP</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P8300  题解</title>
    <url>/2023/08/29/P8300-solution/</url>
    <content><![CDATA[<p>分块题。由于笔者对于维护凸包之类的东西掌握的不是特别好，而李超树在解决斜率相关的问题时又几乎是万能<del>（不用推式子）</del>的，因此本题解采用分块 + 李超树的做法。</p>
<p>思路是很简单的：单点修改的时候，暴力重构一个块内的李超树；区间查询时散块暴力，整块直接在李超树上查询就好了。不过这个东西的复杂度是 $O(n\sqrt n\log {\sqrt n}) $ 的，可能没有那么优秀。</p>
<p>这样这题细节就很少了。但要注意输入中可能有 $A&gt;B$  的情况要交换。</p>
<p>代码（开 O2 通过）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lid (tr[id].lson)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rid (tr[id].rson)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((L+R)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,yu=<span class="number">336</span>,rt[<span class="number">300036</span>],tng[<span class="number">3000005</span>],top,cqt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> t,k,b;</span><br><span class="line">&#125;nd[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">f</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1ll</span>*nd[id].k*x+nd[id].b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span>&#123;</span><br><span class="line">	<span class="type">int</span> id,flg,lson,rson;</span><br><span class="line">&#125;tr[<span class="number">3000005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	tng[++top]=id;</span><br><span class="line">	<span class="keyword">if</span>(lid)<span class="built_in">clear</span>(lid);</span><br><span class="line">	<span class="keyword">if</span>(rid)<span class="built_in">clear</span>(rid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(top)&#123;</span><br><span class="line">		tr[tng[top]]=tr[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">return</span> tng[top--];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ++cqt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> t,<span class="type">int</span> L=<span class="number">1</span>,<span class="type">int</span> R=<span class="number">1e6</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!id)&#123;</span><br><span class="line">		id=<span class="built_in">newnode</span>();</span><br><span class="line">		tr[id].id=t;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(t,mid)&gt;<span class="built_in">f</span>(tr[id].id,mid))<span class="built_in">swap</span>(t,tr[id].id);</span><br><span class="line">	<span class="keyword">if</span>(L==R)<span class="keyword">return</span> id;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(t,L)&gt;<span class="built_in">f</span>(tr[id].id,L))lid=<span class="built_in">modify</span>(lid,t,L,mid);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">f</span>(t,R)&gt;<span class="built_in">f</span>(tr[id].id,R))rid=<span class="built_in">modify</span>(rid,t,mid+<span class="number">1</span>,R);</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> pos,<span class="type">int</span> L=<span class="number">1</span>,<span class="type">int</span> R=<span class="number">1e6</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!id)<span class="keyword">return</span> <span class="number">-1e18</span>;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ret=<span class="built_in">f</span>(tr[id].id,pos);</span><br><span class="line">	<span class="keyword">if</span>(L==R)<span class="keyword">return</span> ret;</span><br><span class="line">	<span class="keyword">if</span>(pos&lt;=mid)<span class="keyword">return</span> <span class="built_in">max</span>(ret,<span class="built_in">query</span>(lid,pos,L,mid));</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(ret,<span class="built_in">query</span>(rid,pos,mid+<span class="number">1</span>,R)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> l=<span class="built_in">max</span>(<span class="number">1ll</span>,id*yu),r=<span class="built_in">min</span>(n,(id+<span class="number">1</span>)*yu<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span>(rt[id])<span class="built_in">clear</span>(rt[id]);rt[id]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(nd[i].t)rt[id]=<span class="built_in">modify</span>(rt[id],i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> op;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;op);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="type">int</span> t,k,z,s;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;t,&amp;k,&amp;z,&amp;s);</span><br><span class="line">			nd[k].t=t,nd[k].k=z,nd[k].b=s-z*t;</span><br><span class="line">			<span class="built_in">rebuild</span>(k/yu);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="type">int</span> t,a,b;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;t,&amp;a,&amp;b);</span><br><span class="line">			<span class="type">int</span> bl=a/yu,br=b/yu;<span class="type">long</span> <span class="type">long</span> ans=<span class="number">-1e18</span>;<span class="keyword">if</span>(a&gt;b)<span class="built_in">swap</span>(a,b),<span class="built_in">swap</span>(bl,br);</span><br><span class="line">			<span class="keyword">if</span>(bl==br)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=b;i++)<span class="keyword">if</span>(nd[i].t)ans=<span class="built_in">max</span>(ans,<span class="built_in">f</span>(i,t));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;(bl+<span class="number">1</span>)*yu;i++)<span class="keyword">if</span>(nd[i].t)ans=<span class="built_in">max</span>(ans,<span class="built_in">f</span>(i,t));</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=br*yu;i&lt;=b;i++)<span class="keyword">if</span>(nd[i].t)ans=<span class="built_in">max</span>(ans,<span class="built_in">f</span>(i,t));</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=bl+<span class="number">1</span>;i&lt;br;i++)&#123;</span><br><span class="line">					ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(rt[i],t));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ans&gt;<span class="number">-1e18</span>)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;nema&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>题解</tag>
        <tag>李超树</tag>
      </tags>
  </entry>
  <entry>
    <title>初赛的坑</title>
    <url>/2023/08/29/basic_knowledge/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a0079df132de8e355a697d7d2ff44ac05b17fd4398f4a3890f5e467b7a798937">05cd41db3361879aefb4267e575d7f2d0fad6e8fb5cc2dfe3712cdf9a2708595c09c4c677f21b8d439f0cb628c0d0bdf361fe1206d3e1f7caa70ebc7c12c187fa01f129d8e81129ed7e9e246c451774f965c4ebfc6d3c5172555e4b4986ee384a5e20639af37d3dbbe6bd6389c9e1ee624c20387c003e31b6d9f7a47f3612a45d9e72213022d382626a9eff828a703e80ca826dc7e7f8f6db9b2e3627c2cf45c1aaadb5e39f96490327bd63fce173f89a535d8770b7a2bca4228093dc2798e9b871975fb8997c7d559241d61f7e8556f497a650560eee532491b078b809d94c25d6ebfe01abd675fa784ee2597c29b3e7fddf331484586c30e772c7544466d749b7b39e62174748511a8dbfaeaef4d940c222247c9e1cb4e6da1648f9f3b4d448389778a38b04d39bd09df2594edde13e259afee7399c6d259ab00c41e6986434706e809aea37a7389d1102a7119ee71558c1c6ee41ba58cd9f1a8211f54584959b536ec61b52ab3de0953a13727ab8d741ac596726063df0a5b6c3ddf584768eec666fa73a8a3025cdd4b3e41b8e3bf50de5d7beaf36d0d4f3ff81401acb476c61aa0556122a828fc9a96239c0e9e7e4422b64f1756f26508ac2b18690e025b6ddd15472a054c7aadba750171f45036e43a90b38978bb4fad106f26c6fb0a03151f0891695e700e65210d18c6f30f156e5f7a7f00c6a712d3ed1a55249bee4c99c222892ef99a0a54da9b57d790afa32b900cceef5b45c91e5f7b659ee2f3127f0abf1f13794804b61077128a17a75dbcf7bd59cc5fcbfed4fa964eb7d8df35dbc278d902609b972db39dd3092c1ca4f6e5f5ad095893f148f0b872a63a924930c643e884ab92b014b63495b9e8283e7c51a56e23fc5d270dd258f3f447a73b7e6aeccfabde7395de9284d56c86083609f53f81b94fb6f6826015ce9247d786845a2e64b11328dc798a65559dba94ba06cb5d63eeccbd220b9d2af8cff4973affe108458241d5d6faafa384a40af3b4a5efbe8d63e8d769f04fce48621aa7ee01c2959cc3059594585567af0fb9e3a5cd8b330a210d3b61b69e9bfe8aa03d47d1b4e1451d82f7d74d11ad3767b46bb915aee9384681362b9d298d6ae5e8ebe6b964b36cade78673367394ad69f8f27f27b48fd73533b1b566e72b14368e8ec3efee5db1e2cb6695f93fd4257bd555d7c13a451518c641ac2da22578a4bf6cc1ed1b1eea2e92c6b9336f3e75d1911c710a478640ffd50f814f718589e2521f47d2b2ed13e94893ce578e3eef341f187bd22103cd1122f075ed1773a66b326de8e285f91d9fc9b9dcacc730cb834dbab963ded3929a5e63e34c8b1678ab53c55777120de129c90f15a8078b619718be1e286f57736bea7b6b2e414b472925b57b3316da774306c106b9e46febda2903a1d8e0b08b9a65d4a0d069bf32662ea19bf8d383100c1ba09118c0bc5f68326d2ce07d7dd51e16b32d463a3019a23a287ac30aa9757aadeb92bf4ba400b5cb5e5ee804e4dda67552d2278b76d179928650b943cde426e92ada008f9cae650b93247fa9338e5844e7f6f731c174cae48ac4cce6f82e2008cac7a7ab5709353fbf94673dcf9dc931602fc02783f66250de6c17e6f302993d59ce829ca7c9373eb3413ac3a9a5a66456f675d0eaee214fd2fbd05986d016aad4bbf925875438123fca9d2e45dea62df77d0f721865682f48919d20cc62dede3b903c03d459cc1eb466ad1f45b27ba65039ac3efdf2c311450beeec6860ce5fd49bf8e7d0e80c344c652e2a8376330dd06a85be249fcf0717bff017f4e694bbc10ba2c94ef3c2ebd4d0c73d240e3e2eecccb8b463cb569af5a41edac056b3d287028856d7b385afa74aaa001548cd12f423d342d15e58e1684c7709f90bec29785832c6db46077a63e7097b23f1b56c83bbddf5c834d8a1a28a4f46395f117c0d867476e39c211b10fa7aa61ecd7d92a07e5dbfd6c05a94941139892b642b6256557eb9c1035d68d4a84bd6d0b446e3183cae169245ce6916574e1bdade04340c6fa13ec550a4aa5e5ea345b5ca61511679b096e5e803df4bb1c0e9834b57849794182c331874c709dc059b61ad9b49874cdf99107eb6688398d0355afa3cceb0d909d93bc0adc7a3256d22d809f96cce666b724f901475d31df498ad5b2a21d6f3774b77d4c379ce64bcda9a85dd36c63c9e468cfc43ea96817bd8785d95b02bb2dc6f701d6a976d68ab6d0fe5115880afb9a17b80a81fa10906cee9d7d6a2f856b39f8325afc63b4a17e455058e8e852cfdb489afeb6816b0a9c56d968ad89044405087ae5af393714479e919de2ab72efe7e47912c37f467e26e2617994f9918faaa1077b7f694ea2e4e0ffcd656caae524ebf780e005efd66ece7113274263996112589b0c9a9ccc17526659a2a75933ef34dc482aba2c65e2529a1fe4b623347d6e41d17833499886ce6f83dadf6fae898540221b86b2f254c7a4c36789307ad15c9201fdb1f8d43af68f0fe3dd361ca4dbe202d28234dc855eb023c3e56a80c1597bae6172c21eacaefd1c460599799113fcecaa5de5ae62c9def69f287e7b8c8381b84ba464615f51a8f2c5ead5611498637d82aee9aed9882934ef0b17849a0921d0fa39f4dd373efd9d5f5c20e35dee9a7e302872caa4a255c9f6547ab9b512511f4794ac9a99f663748bf35beaa78b649248ffcc1e0a1732d3d85c3ec088514114d24b289ba0ec8004c5a745b246c7de56691654a6e07566c27680e7c02d96853ddd0e2cc49913f0727ed5fc6c53e12782ba3054218eab3d0b2a7e4e41b13e15caa8a5ffef096d067d9416a6e287ebca870fe1a77797dffd3b50307c66a1a66eb40600f927593a1d3a6ba07735a4e989e726319a3a44952c268115d545f3104e3b349118057c7dee466b1127c0c31d70dfcc88d6e0775adcd8855f2744dab91b48b7f8eb6cdbb99284699e2afc55a59cbeeab69c126c32a62fe6fa5d7d1a28f2bb010d81b4834f3cb53dfa041f508d7a4cdcbc349742755cec1de5f7293ec23283aa72c6710d8e14a2cefc9dbed1cbb7217a33b8cfe05de83a696189e7997a15ad37f095fa26e09ce04764cc233683286dd826ac5c6bede92209f80e6dafc5ccafc6b5ab1794e8cb0a6f1c33f843a861d72b813d4b858986288b935a66b2888b2cd665b2e38dfc8f621fa1db1a532a7758604538d68931c5c6a316d828fec9e6915f91ad708eac18b06ad952fbc48cb07f600b9f749d0826b465c73c0ce57a426f8dd1a758ffbab71955bdbe3c72e532c797fcfb0750e0b04f09317aaa14231bfad6c8b5940517c00c2a498d7b8175ee91e435ecae20a626aa8f5e1ff4be41347b5640fe549d97aee1fec8458a2e78d6ac6ee884179e4234d944564ab37338a569c75d9f667b458bcd0b63d5059a5038627b7c735dde8daf4a8dee276aa9be4e291730553214c1189302ec21417b1b291af5db2a59269a88946d90fca958ae0fc9ab5e9efeb79b7d1be4299bc6fd5c987fec7e5048a2ad05e87c5209fd2391b40e64a3f2914f4f4e6a9234eb5d350b3001e15c505bd6297d833063c55d3474b74647e6343fd12cfce0b5fb5ac2a48d1b5db1174158f8548aba86c77067f5a7057d3e6c94797a209d38da55212812fb4f7fecd9d16dca29e833e3d0975841053d8ccc90607d22da2e5c789536f2315d039d65e3fe3ed40f534f3dec5e29d5001b9f50871e1366b2985c09423b3e204855648ab1401eb2177303f6ec6dcd9c7bf34372d131052f920db98bbf82d3727fa03857b466904e576ce94c012c164eb0166ffd99902a5f86ddf67d8a3104b1be4b1b764a53ae271a6a775a405554218d9c855abf3df0ad6754391f26e5bc4af38d32c755ae0d0383a98790cd6a2cbcae5fdecab70967099a5a4215e08aeb2281a9ad4f274114dbea8fb577be50e09a5eb753872eab327f129b89b6dd27afbbeddb50feda45217405b955a2b7fc7f8de4b2ee0fe9a2b6d2ea70f896c7b0bb162981b3288f9ba0a5e5c3c6d99431c456ac4892d5b37ebd0165f5eba1b5d936dfab27c1e9ec2665f586e65579c89eeb09e18b61edd463f2b2e174967b208d8aa8c606c5d0e5d7677992f323b7b017f3cabc5982234e0da1bfe7c89703b65fbf3fc907400fb0ada51913e3ac7d5d3a28d80d75ffd09aa7dcd37da8a7bd10c94ba5c9f040e0fab41f1f0a8068789722aa02d34f6467f52311a352205167d242d8afb42d72a6db8b3a561e417814af88f38c3583ce7ff01adecd7c812ececbb96c76257fc315a29faca4650985535391f830286c59c3296c7b185f3308f5556ceae4556ad0f62482ed1444c63f960cacc2470615fbd4a7d12c348302369830a8f8e225484f6a6e967ad5fdb1dcd101e2b767f9010462630a6f81716a05f784dac08a530d7f23aa17ed5c84f742e740d33d8a60602dd64c6c73016acedcfd7855a0703fd1b07797d403bee796a04491da8539c1ae9e9bf1683bef32d2fb7f0f20b8a0059b2b7e4a3b142fb191216af8f39c9f4997727154a9fea38c8e6610841a38a82e4acbb1edd9802314c3be9ea28c9aa74defad2d96f4a3ef4cd11b4e0923563212d22a4eb4c9c1da43a2aa4f5d82bfcc8fdc798221bab924173d265e07222a03d4d1d7611dfff8f4ed0afec4af142ae7ce2f47d853d4b62088398b5c0417c283a227b2115e7fe13f49afa7b80a0c5494c7956e9605f73260c7f9886374777ab67812d170de2c0bb18aac6c5e7a6c1016bb187b10b62a069c34618eb46976d4752d10fd085bf11951e255560474557fcc84586fa47dbb1f592e0e0bc281efcd207e415c0226aa95bc932ed4f5c4f0666eb6563407aa9992c59306d0e33bfbbb38b32fdb1e44b340dac41e240c7081a5c70e6c76d45f74241fdb5a6031846b39787bbdb18b4a400b17c323382dc971692c47b8d214506c47af51dd22aa611c952fba5c59df6aebbc17fae30ebababa880caccc07412147c46668128d9482a2af7ed1077e1819231d38e731a0b54a6228bec2f8a61cf3d5dbbb39261be247ce0be0efa0468569abbe5d99525fcd7066b8db9fdd588e66964924ea5d56c39cefc1420b034f5702899d6d8a1abcf8623eaf9a3f8462f0d52827df0cf41ea2de7e9288ff5a6b12694ab244fc20d9e0d6626cf9ad2487e0c707e97dbcf9083c893b0aa8ed2de9954e348619afa73047def8dcb49c50fba4c82cef337047e17de5df2158f8071a87981b703a08f64ab430867414d976b610ea702e85fde0a77ea75637f8417f1a560f16ecc85a24564599e7f95902adc7c0a64f8a4fb3dd5156dad84250b3d35efd0c0d88d26d2c0832c0e2300239c97633a13e46da6edaf04b0fd8561c5f9951d007292730ca35709b6c4576fa6ef834712a6fee8206f80a85ff8d20730dfc093e60c386f3b4b827f38daf64fbcc92e7e3db2a136d9a5a125543a50e0150d6bf63a6d73959a69cbe061a98210617cbaa19b10f4613bd0d5501565fa569197f7ed70d69e98ec1b2fc57f55a18d27972b379221827d77bc972b719af06637fd5be74b81f88443118d399384cc2922111720bf8ea997bce62c7dadc1e884aa628583932ea320ac8ef2c2aa5ed31e1862151e6efa39cd27576f6a2f01de2f41c482ec6abc8865d5b51b1cdca88be41e6d31b982afe1f7ad3d41aa4392e927d272314db7c04ad38f3f0e2e929531ffbf531365be4db12f621af6e5b9fd875181d7eb68e6834f84aa351a9ef77c43396846f56c21951f73f7a01e939ed08a35e668da581247404bf7168b4c6c797bb1623bb0102e2c6100081673f94260db9296c07c108176ec504be7651c16c692bf92c608ef8ee8991f9b598c3ad555514c152da3932f541c39b4364eeae8ee6bb270428454c33120e4a06eaed448fa288c135a40a6a522e60f93678d8ca191c1092d74b8796c992f725851fbb2055e5eb5dafdfff50c14e6f6506043ddde4469b469889749ea50652ccb527f15235dd5f3dc16a0c1eb45d12fa35b31a66d9e495a07f1cccf58b303e343bfbfa8a3658527c76a61d2c37ac8438742076250b22761fa0801563220edd3a5d3b00007735203e055af1e422b553a79c479d91bb71b01a0951a9ed67c017776ff2f5493fee4c132000f85ce81db9b9d78c41795c8f00ab8f19c394cb541bce8356169d181c0e71d08338fdfef09115c575b569b5c6af1ba1af1a4a438dc5d3b32211d3c1b2c3cd528e7468b6a66ec83ad64f9abcae92e5c1361891b735edad179bd5ff9e2de6f60a76cbaa64dab44e8db982c7793b7685605ca9c84e927eb641a6e73464f354afbd8f980bbf19c9d4de759dc0162df8119ed0eff8360cb43024db25a26acc2e455c23523b4e054f5c214d9d0d3d2f1e20d10a14b27456c4e4e836ff13d0fb93316d4550d1e7827505f47dc8fdc5b7410bf114d7c863ee254432c4cb75975c57a0a19c14e0dcd0d653e8110bfe67316f8f3db4880ada0c1379bad7c07773c8f7348a8f0a6b6f8873f04d62ca8212f9dd7dadc02efd3fc01844915d9994c9e50d61b5e0697830d58f8081e3411121e89580858ddaa8ba3438de719d4d466d20adfae04692bedbfa9ab388fa2d8e6c8a15b82c701212f3f07edd29e3d9647651f6e7cb8491bb599ce5a77c674e2d3c5590c85b7cc72d1db7d77bf5502d48b8da4a7b11c2a6c4c1b191860950a6df658fbd6401a1408f8f72b71be4f35f7bde6c31e29be92085e25060275dd424bed8dc0e88d683cae70f2fc5d6c5e0ec1b78cbd65662d14cbd340c4868e30bdb5f50a01568ca1124925bf75738f0a1380aa4486fdb496d65591743435b3e0d9026328ccab150ce78fab0be19d829de3cac0a30048e4830439e2a7c9585a8c0c3900e6db363bf8a2dd7c2f7bc045fa196372ed39478d5cacccdc2a29976e1f0bf44d6349826fc76cea83ca995f79537d258777433aee2b7882022d8a91d10407425b9e43d241e6af27a2305ee16b7eb51b669e809918575c9aa2119cd7116951a6ffbfa03962ea06e2a64e61744061de04aee201eb5ad694d8257c2354e1fde949b49594057ceaf5d785810dcab403be41f567ede7d077ae3027f804819a3c5519a94eb5a0203bdd61962fe7d1a00cc7c8bb225b0a3f25c4ad07c0906e58a3291b07f2714930686d7dafc5a093b7e464d6b2b60b6e19a43786aa4fd47b5c1656fc976de692f6252f74a558d01b07d4cd01df28d9add08612959ef108863d4b9538f34bb6f2afd78ca113bd7a126fd9d85c499a8927dd61be63b30b9e5a71bf6d14a70698b2f283ba85d06e2636bcad6667a82e35e1c44ddcedcb1c40086edc4609f15e5370cf1516d2e6c0e9a130fee2e27acf0bd3bc1badf5911fd1c620a5ff5c9cd65b45cf6284d56684e5895f12959d8abbf4fa8ae74dca1894f310787b83a74dde09795d5539d7f0679b7ccc5d87a00f036e53fa3bb8996065cb606d57ef85b3b8b7ac7439fcc9917145881de9d8fc0328eec4e9bab46cf9e8b03f456138c4570538130d4e85552bf4cea288be21c975f43f32709adaa284166e1b464cecbc33bd9448c3dab5f5ff5913a81b21ee003d0b307fbea1956463f577355b41236c736a8b251050c7d9cce5a28cbf7cf74a3813672414b174fb7b8ef670498a38f89a93e86078caaa3af9d842653b7e40d5573e3891500c3cb669581c163f6361e4d7d6a94a0ea0cd96a6452617900e697e12eac10bc0d9f0fbd19a55300df608e10c8120693d50013ea23770</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>卡常小技巧</title>
    <url>/2023/08/29/faster/</url>
    <content><![CDATA[<h3 id="IO优化"><a href="#IO优化" class="headerlink" title="IO优化"></a>IO优化</h3><p>这个没啥好说的，注意Obuff如果手写栈会跑得更快；以及千万不要用endl而要用\n。</p>
<h3 id="函数内联"><a href="#函数内联" class="headerlink" title="函数内联"></a>函数内联</h3><p>这个没啥好说的。</p>
<h3 id="枚举顺序"><a href="#枚举顺序" class="headerlink" title="枚举顺序"></a>枚举顺序</h3><p>要让可能连续的内存尽量在相近的位置被枚举，例如三维数组 $f[i][j][k]$ 建议按 $i,j,k$ 的顺序嵌套。这一点在<strong>倍增</strong>算法中特别要注意。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>据说这样可以让内存访问变得连续。</p>
<h3 id="取模优化"><a href="#取模优化" class="headerlink" title="取模优化"></a>取模优化</h3><p>对于加法中的取模，建议采用做减法。</p>
<h3 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h3><p>树状数组中的lowbit函数直接define会快一些。</p>
<h3 id="merge代替sort"><a href="#merge代替sort" class="headerlink" title="merge代替sort"></a>merge代替sort</h3><p>对于两个有序序列的合并，建议用STL中的merge函数。使用时需要多开一个临时数组存合并结果再复制回去。这个技巧在<strong>CDQ分治</strong>中很管用。</p>
<h3 id="const-修饰"><a href="#const-修饰" class="headerlink" title="const 修饰"></a>const 修饰</h3><p>对于代码中的常量（如<strong>模数</strong>），尽量加上 const 修饰，会快不止亿点点。</p>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流定理与结论</title>
    <url>/2023/08/29/flow_theory/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="37dfabbe12813df0e252416aa8dc1f53782bfd2ebd92142994ed12d6d10955b6">05cd41db3361879aefb4267e575d7f2d0fad6e8fb5cc2dfe3712cdf9a2708595d5d69984a9cf62b894bca9ba77abbca8da9599c1bb8de0d78c810b06b55ab3f4b316e4a0ae0dfa34fdef3a6b5cd6c02cd995ae19cad41586e4c58fd2b53c17c08da61f84f9f5a00d5e95a10513e2205a696329181150f6cda76784002fdd0f2cc512e05220b3ec8699a710919f6c3f1d4d41df2e65b27b63ffd589779c919311f29e61d32360176fbde46b5af0d378d0a9e0cf9ab24b46dde7c4f769a2ee1cd7f598c73e3f717d6119ac9c02219c2311cd0bf69ca5abd31f96a54aac9a31f0cebec292bbb86e589735fd8c96d5d38988dd4626e0ae1bcbc7e3a31ac8210b8c9700a4d88d26344c25099e41d5910842f60cfff9933d78aa0edde33068f92dd221ea19ab78e52aff2270ca0fe01f493ee58eec08ccd335b7d2cc218bcdc0949d8a8e8f38f15eb044eee16c98cb7949f41403308ee19eae298cfcd10a7d70e1079f78a7932a5006570d47dece4bbe4e68e2fd5a67a35eb5688cd84bf9839246b383312396d3aeb746d9173054e567fceeedba5cb606bd259fb29f4b2a0a7be0de802bf448226dc09ef3a4de05c6f38fbb970694c02f6a9006858ab97dcf12432f73ba57ee2a3d2ab035c3777e1400a6f1b05319b7aa9868e9cf0fe4babefd204742220c68d7928b5f46e24536157eadbb07c1864fe12eb7b2c1f24eb17cf44a6cba25d472c8fae370a781d87e23be5702f597d3dcfcbc246f04966adef6849de1be14eff9c71793d9b4cbf2323c901ac71e3a8e508de160598d80ace2339b544d03ed2682296fe065e41129bcaedba03545e68a6f2537ad0a48e89c8c95c5947bfef8bd4b1f0c9717fe0c41227372dd2a557d111052021b12710a953d3ee96dd1dd57eca9b7e4045e8bd171415c2aaaae49aa71f8283530cd910e8c699ca7f56275b1a6afc1a6a8093b0159f5589f4a5ce6b7c44bdf558a581641d349ee174618b49d5bf34673dd945bc01fd862fdf64c65223eda044a8d155dcc1d364aec10b4f0d9ec156e1976a0d5ae46d1d0ea7f69fa8a167cbe29d5d12fee21e03fe12e4469f335341bf3b4b4d8fd188b9ff58fe677b2f7128e9a2b08c0c02210bd19f62e1a09f469bb09cde30df1c2116446ee825fc62a5e28e7e86f124a3b01d5b14b2a13efc3e8e21abfc3733835c2ddb2f6a802ee0eab7a1a0d55a268d1888bcb52d4528445c6da2ec05e2dc1115af3045dfa23380d9b9a7df79425ee32af558b3c4071c23eeae98a091d3c9cc0f48eb6c9d2f7a829a16a0fb1138fa106da15d62a0fb2cb9649089e39ef9fdda3dd2110820447fa828e9af3a143cece57e894dae79e53fbfb475496777ed58f4dac370740a52b0a06ade1472e74185b6d3fb2d2db7f0b4c184a29a3ccc09ed09c1cef038e6f7f33ee75484508b840574b3ca9fa2263d41c4e5064a781dfbcc6da45439b23584142e6b79b44c4879576455a4809e3189685dc07021166974b11e2975a9e4fa8b6725cd23b3102e38ce706c3f456610affaeb915066afcac365d089c7a97ee559e16009a1b7a7817268da43a539066656f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/2023/08/29/games/</url>
    <content><![CDATA[<ul>
<li><p>NIM 游戏及几个经典模型</p>
</li>
<li><p>其他典型博弈</p>
</li>
<li><p>SG函数</p>
</li>
<li><p>对抗搜索与其他技巧</p>
</li>
</ul>
<h3 id="NIM游戏及几个经典模型"><a href="#NIM游戏及几个经典模型" class="headerlink" title="NIM游戏及几个经典模型"></a>NIM游戏及几个经典模型</h3><h5 id="经典NIM游戏"><a href="#经典NIM游戏" class="headerlink" title="经典NIM游戏"></a>经典NIM游戏</h5><blockquote>
<p>给定 $n$ 堆物品，第 $i$ 堆物品有 $A_i$ 个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可以一堆取光，但不能不取。取走最后一件物品则<strong>获胜</strong>。两人都采取最优策略，问先手能否获胜。</p>
</blockquote>
<p>结论：对于 Nim 游戏的一个局面 $(A_1,A_2,\ldots,A_n)$ 来说，先手必败当且仅当 $A_1 \oplus A_2 \oplus \ldots \oplus A_n&#x3D;0$。</p>
<p>证明：凡是异或和非 $0$ 的都可以通过一次操作变为异或和为 $0$ 的，因此可以归纳证明。</p>
<h5 id="阶梯模型"><a href="#阶梯模型" class="headerlink" title="阶梯模型"></a>阶梯模型</h5><blockquote>
<p>有 $n$ 层阶梯，编号 $1\dots n$，每层阶梯上有一些石子。</p>
<p>两个玩家轮流操作，每次操作可以将第 $i$ 层阶梯上若干(至少一个)石头放到 $i-1$ 层阶梯上，第 $0$ 层阶梯即为地板。</p>
<p>将最后一颗石头从阶梯移到地板上的玩家胜利。</p>
</blockquote>
<p>不难发现，所有偶数阶梯都等价于垃圾桶。若一方尝试将偶数阶梯中的石子移出(至奇数阶梯)，下一个人只需要紧跟着把这些石子丢到下一个(偶数)阶梯即可，最终会到达地板。这个过程中，先后手是不会转换的。</p>
<p>接下来考虑奇数阶梯，一步就可以把任意多的石子丢进垃圾桶，实际上就等价于 NIM 问题。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P5363">SDOI2019移动金币</a>，<a href="https://www.luogu.com.cn/problem/P2575">洛谷P2575高手过招</a></p>
<h5 id="翻硬币模型"><a href="#翻硬币模型" class="headerlink" title="翻硬币模型"></a>翻硬币模型</h5><blockquote>
<p>$n$ 个硬币排成一行，每次可以翻连续的若干个，要求最右边的必须从反到正，无法操作的人输，问谁赢。</p>
</blockquote>
<p>结论：整个游戏的 SG 函数相当于所有反面硬币的 SG 函数的异或和，而位于 $x$ 位置的 SG 函数有规律：$SG(x)&#x3D;lowbit(x)$</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P4077">SDOI2016硬币游戏</a>，<a href="https://www.luogu.com.cn/problem/CF494E">CF494E sharti</a></p>
<h5 id="斐波那契NIM游戏"><a href="#斐波那契NIM游戏" class="headerlink" title="斐波那契NIM游戏"></a>斐波那契NIM游戏</h5><blockquote>
<p>有 $n$ 枚石子。两位玩家定了如下规则进行游戏：</p>
<ul>
<li>第一次取石子时可以取走任意多个；</li>
<li>接下来，每次至少要取走一个石子，最多取走上一次取的数量的 $2$ 倍。当然，玩家取走的数量必须不大于目前场上剩余的石子数量。</li>
<li>取走最后一块石子的玩家获胜。</li>
</ul>
</blockquote>
<p>结论：先将 $n$ 写成齐肯多夫表示，即用斐波那契数表示且没有相邻两个都是 $1$，则先手每次取最低位的 $1$ 即可获胜。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P6791">SNOI2020取石子游戏</a></p>
<h3 id="其他典型博弈"><a href="#其他典型博弈" class="headerlink" title="其他典型博弈"></a>其他典型博弈</h3><h5 id="威佐夫博弈"><a href="#威佐夫博弈" class="headerlink" title="威佐夫博弈"></a>威佐夫博弈</h5><blockquote>
<p>有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。</p>
</blockquote>
<p>结论：当且仅当两堆石子的数量构成黄金比的时候后手获胜。</p>
<p><a href="https://www.luogu.com.cn/blog/chen-zhe/wei-zuo-fu-bo-yi">证明</a></p>
<h5 id="二分图博弈"><a href="#二分图博弈" class="headerlink" title="二分图博弈"></a>二分图博弈</h5><blockquote>
<p>在二分图上，两人轮流指定下一步去哪个点，不经过重复的点，无法指定的人输，问谁赢？</p>
</blockquote>
<p>结论：当一个点在所有最大匹配的方案中（少了这个点无法最大匹配），那么先手必胜。</p>
<p>证明：后手不可能选到非匹配点，如果后手选到一个非匹配点，设路径为 $S_1\rightarrow S_n$，那么把现在的匹配换成 $S_2\rightarrow S_n$，匹配数不变但不包含 $S_1$，与最大匹配一定包含 $S_1$ 矛盾。</p>
<p>扩展到无向图的情况：不指定起点，则有完美匹配后手必胜；否则结论与上面一样。</p>
<h5 id="树（图）上删边博弈"><a href="#树（图）上删边博弈" class="headerlink" title="树（图）上删边博弈"></a>树（图）上删边博弈</h5><blockquote>
<p>在一棵树&#x2F;图上钦定一个根，每次可以删去一条边，若删边后某部分与根不连通则一并删去，不能操作者失败，问谁赢？</p>
</blockquote>
<p>结论：叶子的 SG 是 0，其他点的 SG 是所有儿子节点 $+1$ 后异或起来。</p>
<p>证明：考虑往一个子树顶上加一条边是什么意思，就是对于子树内的状态转移 $DAG$ ，加一个点 $T$, 然后对原来的每个点，加一条到 $T$ 的边，容易归纳说明每个点的 $SG$ 都会增加 $1$。该思路在其他题目中也可以使用。</p>
<p>图的情况：把所有偶环缩成点，所有奇环缩成一个点和一条边（只连他自己那个点），然后当成树来做。</p>
<h3 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h3><p>约定终止态的 SG 函数值为 $0$。</p>
<p>定义 $mex(S)$ 为集合 $S$ 中最小的未出现的自然数。</p>
<p>设 $G$ 能转移到的集合为 $T_G$，则定义 $$SG(G)&#x3D;mex{SG(V):V\in T_G}$$</p>
<p>性质：$SG(G)&#x3D;0$ 为必败态，否则为必胜态。</p>
<h5 id="SG和"><a href="#SG和" class="headerlink" title="SG和"></a>SG和</h5><p>考虑两个人同时面对多个游戏，但每次只能操作其中一个。则 $SG(A+B)&#x3D;SG(A)\oplus SG(B)$，NIM游戏的原理也可以这么解释。</p>
<p>推SG函数的例题：<a href="https://www.luogu.com.cn/problem/P3185">HNOI2007分裂游戏</a>，<a href="https://www.luogu.com.cn/problem/CF1149E">CF1149E</a></p>
<h5 id="反SG-游戏"><a href="#反SG-游戏" class="headerlink" title="反SG-游戏"></a>反SG-游戏</h5><p>即最后一步不能走的人胜利的游戏。</p>
<p>有以下 SJ 定理：对于任意一个 Anti-SG 游戏，如果规定当局面中所有单一游戏的 SG 值为 $0$ 时，游戏结束。则先手必胜当且仅当：</p>
<p>1.游戏的 SG 函数不为 $0$ 且游戏中某一个单一游戏的 SG 函数大于 $1$；</p>
<p>2.游戏的 SG 函数为 $0$ 且游戏中没有单一游戏的 SG 函数大于 $1$。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P4279">SHOI2008小约翰的游戏</a></p>
<h3 id="对抗搜索与其他技巧"><a href="#对抗搜索与其他技巧" class="headerlink" title="对抗搜索与其他技巧"></a>对抗搜索与其他技巧</h3><h5 id="对抗搜索-DP"><a href="#对抗搜索-DP" class="headerlink" title="对抗搜索&amp;DP"></a>对抗搜索&amp;DP</h5><blockquote>
<p>在一个竞争的环境中，双方通过竞争实现相反的利益，一方最大化这个利益，另一方最小化。</p>
</blockquote>
<p>定义合适的状态后，先找到必败态，然后通过记忆化搜索的方式实现，如果当前是必胜态就要在所有后继为必败态的结果中取 $\max$，否则在所有后继状态中取 $\min$。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/P4576">CQOI2013棋盘游戏</a>，<a href="https://www.luogu.com.cn/problem/P4363">九省联考2018一双木棋</a></p>
<h5 id="决策包容性"><a href="#决策包容性" class="headerlink" title="决策包容性"></a>决策包容性</h5><p>如果一个状态能直接到达他后继状态的所有后继状态，在该状态是一个必胜态。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/AT_arc137_c">ARC137C</a></p>
<h5 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h5><p>通过建模把原问题中复杂的操作转化为图形化的，或是易于处理的操作。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/AT_agc002_e">AGC002E</a></p>
<p>通过建模把其他问题转化为博弈论问题。</p>
<p>例题：<a href="https://www.luogu.com.cn/problem/AT_agc043_c">AGC043C</a></p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>群论基础</title>
    <url>/2023/08/29/group_theory/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="cd035f9cbeae2280b82c730ed64839bb0ad825994280f78c211a969a26e976e4">05cd41db3361879aefb4267e575d7f2d3cd51ecf5e79a5aeb906b571463e7640e6d05ffcaa86c563466a59f49f188115aa1de4dce8b681efb469e1a072ecd6c6646af25c2a29c2fd9939ec5c5d41f0180c581f86654c157b71c930cb176a1e904dcd6b440c037b6b8055a7c1d72aed5bd88b785fb210c52e5b5cebf5e5cb573b888cc7975baeea1397e29cb73f7b7dd26fcace52b313ee7976b6d4a42610a8894958ad6511e5e47128d1bf67f7c85ed61ccb51fdbc6eecd85ecf98eaa7d66fa9ab65e36a033bd2efd0b95392806576c03477c1506f14f1630ffc01bdcb0e13629ad621724802ae43111fdff57563fbcbd1fb9c4f7e594e874058a305003990369f49ed0e2d17bfe53059c40f33a99a227a98a59d8e4da3fbf3e8f7228a6544a71b41cf6af2e0c3f0b9bb687c546611880314a375bc483eae671d960fb82be2093b5c96812294a915be60671b02e8a420c274edae64d309bf0f34e188cf58c81fb7f6fcedf9d90e5384d005b9ae7e054ac9a9201e1f111d46a8d3e6d00a4fe501c500c63e4415f970d684298466376eee46f42f6777c6a7135fc330f32eb82584295b2a8fa585c196a54e63afaba06209542a5b445d1f7aa99a8618527ae606a913ff1d07aca55577592e0c694cdfdf2e554dff7803c7016740ea8a5d74c434b720956afd23789229e0ac86886908c256711dab724f91e9773376efe36ddbce8db07a1c82310f4ba12e855e4425ec2d393e3ca0099291ad245e9bd4203b30b6b901d77f4a05c2ccdf23bbd96d8c88e61b1e5a878106dfda1774634fcc9eed6bd2abd7b8aa107aa281d91c173134271a5f9bd9025eccc304fe6770e5a79a4fc96d53edfef91518a57c53f3d2ac3afc2bf6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>数学公式杂项</title>
    <url>/2023/08/29/math_theory/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b98c0d464fff4679599bb7b7ca5952e29cb2805084306dfd09fb2f77c3e4af7b">05cd41db3361879aefb4267e575d7f2d1949322503b48f7d8edebb52667df13576470eab1374094fa970a8d16891c73e790317ee334dbfd4e51ebcd8b086b9350b2556c2a2c216cf78eefaca13dee51e5231479f8ed47852e762d2d46744bb81b46be4a88a3125c3b42a2ca291580f6f59fcea8cf541e3a5ee5beb9ef96790bffff1a43c6121987bc28908cedca515c3219155e958cafccc54caace1e0a5bd57aaddd1c1ba95276c66041847657d54bdda8ce4347a477dbae10d0707a64aba53cb475c3e6cc457b88b83596d3e18b07ad3628e45245d936793bbd3b40ee3df28a0376f8150e149ccf58b6f354b520cad0ce88f4b21665eade014aa2037a8068e2ff7754c6b85cceefead73580ede2317732b0ab968a1870bce05df92ba03f3013151555e354cb91016dd2f1216db3753410d946b1c11970b66115fff392d695b0a20d052c6296c68dfc3e97f8ec5323d772b7e945ec5262c8f99144fc8c1e7a65e73c0e556b6ce313b749bf3c32112872f4569d92038ad92df64ace8b8661ef587e25350fc0e131bcab3b843387d604bcd0f8c1c6a120d598bcda7655e85921a7910f1569f88588a66c2b3eded858c6f7e5bb85fb402cbb03c0777006ccf43c9eb9bff710e112cccb686bb640adefe5b09fc9ac9990886482a418f09b4ee573b5b69ec29ba2334d8c90fa4ccfb020c60bec34fc0ebaa35bf2da4adff651ea2b61adcc1cd91f63d0f9d7968ed0d2b9ec0818a0be86825a984f2bc968cfdcdcadf14ed5a0a801b5b46ee1a0378149a6aafce48f74a144fb2eec7c32f8b0a1dc17f97e88cf48ea95c8a4b4b63342de35482cd453da3e7d42d5eee9398560ffc64170cb8fd6ea2db3bfdc3bf47d0cf2cbb6241bc4a6af390e84a3790d9d5c09b0fd0a1c471179df9b25090f6670a4709d3c04df487b8d18ff42a4731d1e58bc14414cb74f1a7a53a19b035d415532a9c516a47b45f1620782b069a5573666256428e67aa08748aca105bf504c2b4100493c1d14aa29f33bd76048981bcb520ff04c1d8e8f797160d0f6cac5c62f3db0a84aa991b910fac9bc987b8e5db327a6a1e90fc8345e9d7ed62985fd94fb38a75999db992cf67dbc99fe266ad9e2303a73ffcd058f12c561fe86a557e4a102d875e068f688fc7fae4afec303d509a4c60585f815c8814b2c7f17704730a92082489e98f70b0c2bd87f88717613c5c83e178ce66e24a471d366f4cb866bf16c9e1caafec23cb735ab31b4d02d6386cfb6ddb579a6900bad710c980b2b80f60ee3f84d7de702d5bc599c3bb5ce4bce0c45434b6a3c793d084da2ed635d575fa779d122997fb2d3aad7de2b7d21f0eb4af10d551882e33705d90940ec6a38876d51e3b03b5b62cb05f6e542cb7f0a6e38a84040567b5badbda324055500c0d319660bf51f9932217f107549e18043c8f5c47de037aa4012436e3aab602a1aead7ddbd084280c18ddf617a3825a2a5250b0649c4fd114a207c50d6c39f1075d0a0d7a4bc8a5d5605267be5046b71674e7ed45d384f2c374a509a9452e5657a6f361bff0cd2782006d88ae9e0fc9241e4d16508b149725b1c39f9d3a09f68183b3035011001cc11da4b276091c416164a918f500900574ed565abf2c572a816d346922a2102020f9c91ce98d4220b47f3b98b7f49f3603734e7b0de106d07dcf9892fb1f63d289b63bc00c573920c7f5069141e0acfcb146d0bbf94dedde30ccc653cc9d25fd24c55d59ac9de003dfd944dc0a68148fc1df00ef12c0f9d69fb4159a302498b6516c00a54c88608a87cc43f737cde54d4474bed691dbb494452b949f46d0840e88dd2e0d19c46e7983e6bec469387f389379071047b3c1c147a468f426db59e08c36e302c66a1905cc7bb852d11bb009171a1c5c3f3e44b2c5b0612f71e4df32ef4738b734403caaa44b354a539817</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/05/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>!</p>
<span id="more"></span>

<p>This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>莫比乌斯反演  学习笔记</title>
    <url>/2023/08/29/mobius_inversion/</url>
    <content><![CDATA[<p>注：以下内容源自各种各样的资料，不保证正确性，仅供参考。</p>
<p>约定 $*$ 代表运算“卷”，部分出现的 $1$ 代表常数函数。</p>
<h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><p> $\mu$ 为莫比乌斯函数，定义为：<br>$$<br>\mu(n)&#x3D;\begin{cases}<br>1  &amp; n&#x3D;1 \<br>0 &amp; n\text{含有平方因子}\<br>(-1)^k  &amp; k\text{为}n\text{的本质不同质因子个数}<br>\end{cases}<br>$$<br>莫比乌斯函数是<strong>积性函数</strong>，可以求线性筛的同时求出。</p>
<h3 id="莫比乌斯函数的性质"><a href="#莫比乌斯函数的性质" class="headerlink" title="莫比乌斯函数的性质"></a>莫比乌斯函数的性质</h3><ul>
<li><p>性质1：<br>$$<br>\sum\limits_{d|n}\mu (d)&#x3D;\begin{cases}<br>1  &amp; n&#x3D;1 \<br>0 &amp; n\neq 1<br>\end{cases}<br>$$<br>也就是说，$\sum_{d|n}\mu(d)&#x3D;\varepsilon(n)$，即 $\mu * 1&#x3D;\varepsilon$</p>
<ul>
<li>引理：$[gcd(i,j)&#x3D;1]&#x3D;\sum\limits_{d|gcd(i,j)}\mu(d)$</li>
</ul>
</li>
<li><p>性质2：<br>$$<br>\varphi * 1&#x3D;\operatorname{id}<br>$$<br>两边同时卷 $\mu$ 可得到 $\varphi&#x3D;\operatorname{id}*\mu$</p>
</li>
</ul>
<h3 id="莫比乌斯变换与反演"><a href="#莫比乌斯变换与反演" class="headerlink" title="莫比乌斯变换与反演"></a>莫比乌斯变换与反演</h3><p>设 $f(n),g(n)$ 是两个数论函数。</p>
<ul>
<li><p>如果有 $f(n)&#x3D;\sum_{d|n}g(d)$，那么有 $g(n)&#x3D;\sum_{d|n}\mu(d)f(\frac{n}{d})$</p>
<p>这种形式下，$f(n)$ 称作 $g(n)$ 的莫比乌斯变换，$g(n)$ 称作 $f(n)$ 的莫比乌斯反演。</p>
</li>
<li><p>如果有 $f(n)&#x3D;\sum_{n|d}g(d)$，那么有 $g(n)&#x3D;\sum_{n|d}\mu(\frac{d}{n})f(d)$</p>
</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>莫反常常与数论分块+前缀和结合，加速运算。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>考试检查事项</title>
    <url>/2023/08/29/remember_to_review/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>推荐结合阅读<a href="https://www.luogu.com.cn/blog/AIQ/ka-chang-xiao-ji-qiao">这个</a>和<a href="https://www.luogu.com.cn/blog/AIQ/chu-sai-keng">这个</a>。</p>
<h2 id="写作缘由"><a href="#写作缘由" class="headerlink" title="写作缘由"></a>写作缘由</h2><p>还用说吗？显然是不想太快AFO啦！</p>
<h2 id="主要坑点"><a href="#主要坑点" class="headerlink" title="主要坑点"></a>主要坑点</h2><h4 id="数组大小"><a href="#数组大小" class="headerlink" title="数组大小"></a>数组大小</h4><ul>
<li><p>数组需要定义大小，且至少多开1，否则就要写const使其静态。这一点在DFS类的题目中特别注意！</p>
</li>
<li><p>不能太大，否则TLE&#x2F;MLE，都不是什么好结果。</p>
</li>
<li><p>也不能太小，不然RE&#x2F;WA，也不是什么好结果。</p>
</li>
<li><p>在建双向边、存线段树、高精度乘法等题目中特别要小心！</p>
</li>
</ul>
<h4 id="数组越界"><a href="#数组越界" class="headerlink" title="数组越界"></a>数组越界</h4><ul>
<li>处理到0或者1时一定要特判，不要偷懒！</li>
</ul>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li><p>十年OI一场空，不开long long见祖宗。</p>
</li>
<li><p>有些时候还卡long long，注意是否高精&#x2F;__int128。</p>
</li>
<li><p>开了long long，要检查数组是否爆空间。</p>
</li>
<li><p>double在数据过大时，精度很差，注意是否要优化。</p>
</li>
<li><p>long double：数据在1e9以上要用，输出时printf(“%.2Lf”)</p>
</li>
</ul>
<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><ul>
<li>不多说，删注释并检查打对freopen没有。</li>
</ul>
<h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><ul>
<li><p>对于整数，最好都用快读快写，至少用scanf&#x2F;printf。</p>
</li>
<li><p>对于字符，用getchar()或者scanf。</p>
</li>
<li><p>对于字符串，用cin&#x2F;cout。</p>
</li>
<li><p>对于换行，建议用putchar(‘\n’)，最后一个用endl</p>
</li>
</ul>
<h4 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h4><ul>
<li><p>每一步运算都要取模！</p>
</li>
<li><p>快读时也要取模！</p>
</li>
<li><p>做减法时加上模数。</p>
</li>
<li><p>在确保正确的基础上，因为取模很慢，所以尽量手写取模或少取模（确保long long存的下的前提）。</p>
</li>
</ul>
<h4 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h4><ul>
<li><p>矩阵乘法不具有交换律！</p>
</li>
<li><p>减法不具有交换律！</p>
</li>
</ul>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><ul>
<li>位运算的优先级难以预料，一定要加括号，特别是！、&#x3D;&#x3D;、&amp;&amp;、||这些特别容易错！</li>
</ul>
<h4 id="多种算法的选择"><a href="#多种算法的选择" class="headerlink" title="多种算法的选择"></a>多种算法的选择</h4><ul>
<li><p>最小生成树，要根据图的特点选择。</p>
</li>
<li><p>最短路，用dij似乎更靠谱。</p>
</li>
<li><p>不带修的RMQ，别再写线段树了，写ST表吧，你的ST表水平已经不像原来那样糟糕了！</p>
</li>
</ul>
<h4 id="二分边界"><a href="#二分边界" class="headerlink" title="二分边界"></a>二分边界</h4><ul>
<li>二分上界要尽可能开大，但是不要太接近 int 或 long long 的边界！</li>
</ul>
<h2 id="出过人命的坑"><a href="#出过人命的坑" class="headerlink" title="出过人命的坑"></a>出过人命的坑</h2><h4 id="循坏次数"><a href="#循坏次数" class="headerlink" title="循坏次数"></a>循坏次数</h4><ul>
<li>如果答案要更新到n，要检查n是否得到了更新（如NOIP2021T1）；同理要检查0是否会出问题。</li>
</ul>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><ul>
<li>对于需要更新size的，要判断是否在一个集合再合并！</li>
</ul>
<h2 id="查出错了怎么办？"><a href="#查出错了怎么办？" class="headerlink" title="查出错了怎么办？"></a>查出错了怎么办？</h2><ul>
<li><p>发现有错，要将相关的所有变量做更改。改完后建议全部重新读一遍代码，再看一次有无缺漏。</p>
</li>
<li><p>修改后不用的数组变量及调试用的变量要及时删去，可以省空间且看出是否有漏改的地方。</p>
</li>
</ul>
<p>未完待续……</p>
]]></content>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>slope trick 小记</title>
    <url>/2023/08/29/slope_trick/</url>
    <content><![CDATA[<p>学习的过程比较艰辛，搞了半天才搞明白，所以记录一下。</p>
<h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>优化形如 $f_{i,j}&#x3D;|x_i-j|+\min f_{i-1,k}$ 的 DP 转移。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>由于绝对值函数是连续，下凸的一次函数，因此几个绝对值函数相加仍然满足这一特点，即归纳证明将 DP 式子的第二维当做横坐标后，每个 $f_i$ 的图像也满足这一特点。我们考虑存储每次斜率 $+1$ 的横坐标，从而快速转移 DP。</p>
<h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><p>首先尝试列出朴素的 $n^2$ DP式子，如最开始的例子。然后考虑 $k$ 的取值范围。假设每次转移中 $k$ 的取值范围是 $[l_i,r_i]$，则整个函数有以下变化：</p>
<ul>
<li><p>最低点右边的部分全部向右平移 $r_i-l_i$，最低点的范围增加 $r_i-l_i$。</p>
</li>
<li><p>在 $x_i$ 这个点，斜率增加了 $2$，即维护的点集需要增加两个 $x_i$。</p>
</li>
<li><p>若当前 $x_i$ 在最低点左边，则左边下降的部分的最后一段变成上升的，反之亦然。</p>
</li>
</ul>
<p>由这 $3$ 条关键信息，我们可以用堆来维护点集。比较好的例子是 <a href="https://www.luogu.com.cn/problem/CF1534G">CF1534G</a>，感觉是整个过程最完整的一道题。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
</search>
